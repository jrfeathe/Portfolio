#!/usr/bin/env node

const fs = require("node:fs/promises");
const path = require("node:path");

const DEFAULT_INPUT_DIR = "apps/site/data/localization_responses";
const DEFAULT_OUTPUT = "apps/site/data/script-strings_en-ja-zh.md";
const PART_REGEX = /^script-extracted_strings_ja-zh_part-(\d+)\.md$/;

function resolveRepoRoot() {
  return path.resolve(__dirname, "..");
}

function parseArgs(argv) {
  const args = argv.slice(2);
  const inputIndex = args.findIndex((arg) => arg === "--in" || arg === "--input-dir");
  const inputDir =
    inputIndex !== -1 && args[inputIndex + 1] ? args[inputIndex + 1] : DEFAULT_INPUT_DIR;
  const outputIndex = args.findIndex((arg) => arg === "--out" || arg === "--output");
  const outputPath =
    outputIndex !== -1 && args[outputIndex + 1] ? args[outputIndex + 1] : DEFAULT_OUTPUT;
  return { inputDir, outputPath };
}

function splitMarkdownRow(line) {
  const cells = [];
  let current = "";
  let escaped = false;

  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];
    if (escaped) {
      current += char;
      escaped = false;
      continue;
    }
    if (char === "\\") {
      current += char;
      escaped = true;
      continue;
    }
    if (char === "|") {
      cells.push(current);
      current = "";
      continue;
    }
    current += char;
  }
  cells.push(current);
  return cells;
}

function normalizeCells(cells) {
  let trimmed = cells.map((cell) => cell.trim());
  if (trimmed[0] === "") {
    trimmed = trimmed.slice(1);
  }
  if (trimmed[trimmed.length - 1] === "") {
    trimmed = trimmed.slice(0, -1);
  }
  return trimmed;
}

function extractKey(keyCell) {
  const trimmed = keyCell.trim();
  if (trimmed.startsWith("`") && trimmed.endsWith("`")) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}

async function listPartFiles(inputDir) {
  const entries = await fs.readdir(inputDir);
  const parts = entries
    .map((name) => {
      const match = name.match(PART_REGEX);
      if (!match) {
        return null;
      }
      return { name, part: Number(match[1]) };
    })
    .filter(Boolean)
    .sort((a, b) => a.part - b.part);

  if (!parts.length) {
    throw new Error(`No part files found in ${inputDir}`);
  }

  const missing = [];
  for (let i = 1; i <= parts[parts.length - 1].part; i += 1) {
    if (!parts.some((part) => part.part === i)) {
      missing.push(i);
    }
  }
  if (missing.length) {
    process.stderr.write(`Warning: missing parts ${missing.join(", ")}\n`);
  }

  return parts;
}

async function loadRows(filePath, seenKeys) {
  const content = await fs.readFile(filePath, "utf8");
  const rows = [];

  content.split(/\r?\n/).forEach((line) => {
    if (!line.startsWith("| `")) {
      return;
    }
    const cells = normalizeCells(splitMarkdownRow(line));
    if (cells.length < 4) {
      throw new Error(`Malformed row in ${filePath}: ${line}`);
    }
    const [keyCell, english, japanese, chinese] = cells;
    const key = extractKey(keyCell);
    if (!key) {
      throw new Error(`Missing key in ${filePath}: ${line}`);
    }
    if (seenKeys.has(key)) {
      throw new Error(`Duplicate key ${key} in ${filePath}`);
    }
    seenKeys.add(key);
    rows.push({ keyCell, english, japanese, chinese });
  });

  if (!rows.length) {
    throw new Error(`No rows found in ${filePath}`);
  }

  return rows;
}

async function main() {
  const repoRoot = resolveRepoRoot();
  const { inputDir, outputPath } = parseArgs(process.argv);
  const inputPath = path.resolve(repoRoot, inputDir);
  const outputFile = path.resolve(repoRoot, outputPath);

  const parts = await listPartFiles(inputPath);
  const seenKeys = new Set();
  const rows = [];

  for (const part of parts) {
    const filePath = path.join(inputPath, part.name);
    const partRows = await loadRows(filePath, seenKeys);
    rows.push(...partRows);
  }

  const header = [
    "# Projects + Tech Stack + Resume + Dictionary + Timezone strings - String | English | Japanese | Simplified Chinese",
    "",
    `Source: ${inputDir}/script-extracted_strings_ja-zh_part-*.md`,
    "Generated by: `scripts/compact-localization-responses.js`",
    `Rows: ${rows.length}`,
    "",
    "## Copy strings",
    "",
    "| String | English | Japanese | Simplified Chinese |",
    "| --- | --- | --- | --- |"
  ];

  const lines = [...header];
  rows.forEach(({ keyCell, english, japanese, chinese }) => {
    lines.push(`| ${keyCell} | ${english} | ${japanese} | ${chinese} |`);
  });
  lines.push("");

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, lines.join("\n"), "utf8");

  process.stdout.write(`Wrote ${outputFile}\n`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
