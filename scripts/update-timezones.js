#!/usr/bin/env node

const fs = require("node:fs/promises");
const path = require("node:path");

const DEFAULT_OUTPUT = "apps/site/data/timezones.json";
const DEFAULT_EXCEPTIONS_OUTPUT = "apps/site/data/timezones-exceptions_en.md";
const LOCALES = ["ja", "zh"];
const FALLBACK_TIMEZONES = [
  "America/New_York",
  "America/Chicago",
  "America/Denver",
  "America/Los_Angeles",
  "Europe/London",
  "Europe/Berlin",
  "Asia/Tokyo",
  "Asia/Shanghai",
  "Asia/Kolkata",
  "Australia/Sydney"
];

function resolveRepoRoot() {
  return path.resolve(__dirname, "..");
}

function parseArgs(argv) {
  const args = argv.slice(2);
  const outputIndex = args.findIndex((arg) => arg === "--out" || arg === "--output");
  const outputPath =
    outputIndex !== -1 && args[outputIndex + 1]
      ? args[outputIndex + 1]
      : DEFAULT_OUTPUT;
  const exceptionsIndex = args.findIndex(
    (arg) => arg === "--exceptions" || arg === "--exceptions-output"
  );
  const exceptionsPath =
    exceptionsIndex !== -1 && args[exceptionsIndex + 1]
      ? args[exceptionsIndex + 1]
      : DEFAULT_EXCEPTIONS_OUTPUT;

  return { outputPath, exceptionsPath };
}

function formatTimezoneName(value) {
  return value.replace(/_/g, " ");
}

function buildExceptionsMarkdown(exceptions) {
  const lines = [
    "# Timezone localization gaps - String | English | Locale",
    "",
    "Source: IANA time zone identifiers",
    "Generated by: `scripts/update-timezones.js`",
    "",
    "## Missing locale labels",
    "",
    "| Timezone | Locale | English |",
    "| --- | --- | --- |"
  ];

  exceptions.forEach(({ timezone, locale, english }) => {
    lines.push(`| \`${timezone}\` | ${locale} | ${english} |`);
  });

  lines.push("");
  return lines.join("\n");
}

async function main() {
  const repoRoot = resolveRepoRoot();
  const { outputPath, exceptionsPath } = parseArgs(process.argv);
  const outputFile = path.resolve(repoRoot, outputPath);
  const exceptionsFile = path.resolve(repoRoot, exceptionsPath);

  let existing = {};
  try {
    const payload = await fs.readFile(outputFile, "utf8");
    existing = JSON.parse(payload);
  } catch (error) {
    if (!error || error.code !== "ENOENT") {
      throw error;
    }
  }

  const existingKeys = Object.keys(existing || {});
  const supportedTimezones =
    typeof Intl.supportedValuesOf === "function"
      ? [...Intl.supportedValuesOf("timeZone")]
      : existingKeys.length
        ? existingKeys
        : FALLBACK_TIMEZONES;
  const allTimezones = Array.from(
    new Set([...supportedTimezones, ...existingKeys])
  ).sort();

  const updated = {};
  const exceptions = [];

  allTimezones.forEach((timezone) => {
    const current = existing?.[timezone];
    const currentEntry = current && typeof current === "object" ? current : {};
    const en = formatTimezoneName(timezone);
    const entry = {
      en,
      ja: "",
      zh: ""
    };

    LOCALES.forEach((locale) => {
      if (!entry[locale]) {
        exceptions.push({ timezone, locale, english: en });
      }
    });

    updated[timezone] = entry;
  });

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, `${JSON.stringify(updated, null, 2)}\n`, "utf8");

  const exceptionsMarkdown = buildExceptionsMarkdown(exceptions);
  await fs.mkdir(path.dirname(exceptionsFile), { recursive: true });
  await fs.writeFile(exceptionsFile, exceptionsMarkdown, "utf8");

  process.stdout.write(`Wrote ${outputFile}\nWrote ${exceptionsFile}\n`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
